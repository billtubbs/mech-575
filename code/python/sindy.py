"""
Implementation of SINDy algorithm based on code by Steven L.
Brunton.  See Paper, 'Discovering Governing Equations from Data:
Sparse Identification of Nonlinear Dynamical Systems' by S. L.
Brunton, J. L. Proctor, and J. N. Kutz.
Original code available from: https://www.eigensteve.com
"""
import numpy as np
import pandas as pd


def polynomial_features(y_in, order=3, include_labels=False):
    """Calculate polynomial terms up to given order for
    all data points in y_in.  This function is similar
    to sklearn.preprocessing.PolynomialFeatures method
    but considerably faster.

    Args:
        y_in (array): m x n array containing m data points 
            for n input variables.
        order (int): Order of polynomial to generate
            terms for (only order 1, 2 or 3 supported).
    
    Returns:
        if include_labels is False:
            y_out (array): Feature data array with data for each
                polynomial term in the columns.
        else:
            y_out, feature_labels (array, list): where the strings
                in feature_labels represent the expression for
                the polynomial term in each column of y_out.
    """
    assert order in (1, 2, 3), "Polynomial order 1, 2 or 3 only"

    if len(y_in.shape) == 1:
        y_in = y_in.reshape(-1, 1)  # Reshape vector to matrix
    n = y_in.shape[1]
    y_out_cols = []

    # Poly order 0
    y_out_cols.append(np.ones((len(y_in), 1)))

    # Poly order 1
    y_out_cols.append(y_in)

    # Poly order 2
    if order >= 2:
        for i in range(n):
            y_out_cols.append(y_in[:, i:] * y_in[:, i].reshape(-1, 1))

    # Poly order 3
    if order >= 3:
        # Use poly order 2 results
        results = y_out_cols[-n:]
        for j in range(0, n):
            for result in results[j:]:
                y_out_cols.append(result * y_in[:, j].reshape(-1, 1))

    theta = np.hstack(y_out_cols)
    if include_labels is False:
        return theta
    else:
        return theta, polynomial_feature_labels(n, order)


def augmented_feature_library(dfn, dfd, dy):
    """Compute the library of function terms used for the
    sparse identification of rational functions (implicit
    SINDy) algorithm.

    Args:
        dfn (DataFrame): Feature library for the numerator.
        dfd (DataFrame): Feature library for the demoninator.
        dy (DataFrame): Library of derivatives of each variable.

    Returns:
        theta (DataFrame): Augmented feature library.
    """
    # Multiply denominator library terms by each of the
    # first derivatives (dyi/dt) and concatenate them all
    dfd_dys = []
    for dy_name in dy:
        dfd_dy_k = dfd * dy[dy_name].values.reshape(-1, 1)
        rename_map = {name: f"{name}*{dy_name}" for name in dfd.columns}
        dfd_dy_k = dfd_dy_k.rename(columns=rename_map)
        dfd_dys.append(dfd_dy_k)
    # Combine into one library of terms
    theta = pd.concat([dfn, pd.concat(dfd_dys, axis=1)], axis=1)
    return theta


def polynomial_feature_labels(n_vars, order, names=None,
                              vstr='x', psym='**'):
    """Returns a list of strings that represent the
    expressions of all the combinations of polynomial
    terms of a function with n_vars variables.  The list
    is ordered the same way as the features generated by
    the polynomial_features function.

    Args:
        n_vars (int): Number of feature variables.
        order (int): 1, 2 or 3.
        names (list): List of labels for each variable.
            If not specified, ['x0', 'x1', ... etc.]
            will be used.
        vstr (str): If names is not provided, this string is
            used to construct the variable labels (e.g. if
            vstr = 'x', names = ['x0', 'x1', ...]).
        psym (str): How to represent the power
            operator (e.g. '**' or '^').

    Example 1:
    >>> polynomial_feature_labels(2, 2)
    ['1', 'x0', 'x1', 'x0**2', 'x0*x1', 'x1**2']

    Example 2:
    >>> polynomial_feature_labels(2, 3, names=['X1', 'X2'])
    ['1',
     'X1',
     'X2',
     'X1**2',
     'X1*X2',
     'X2**2',
     'X1**3',
     'X1**2*X2',
     'X1*X2**2',
     'X2**3']

    Note, these string 'expressions' can be used to calculate
    the features using pandas.DataFrame.eval().

    Example 3:
    >>> data = pd.DataFrame({'X1': range(5), 'X2': range(5, 10)})
    >>> exps = polynomial_feature_labels(2, 3, names=data.columns)
    >>> data.eval(exps[3])  # 'X1**2'
    0     0
    1     1
    2     4
    3     9
    4    16
    Name: X1, dtype: int64
    """
    if names is None:
        names = [f'{vstr}{i}' for i in range(n_vars)]
    else:
        names = list(names)

    labels = []

    # Poly order 0
    labels.append('1')

    # Poly order 1
    labels = labels + names

    # Poly order 2
    if order >= 2:
        for i in range(n_vars):
            labels = labels + ['*'.join([names[i], names[j]])
                               for j in range(i, n_vars)]

    # Poly order 3
    if order >= 3:
        for i in range(n_vars):
            for j in range(i, n_vars):
                labels = labels + ['*'.join([names[i], names[j], names[k]])
                                   for k in range(j, n_vars)]

    for name in names:
        old = f'{name}*{name}*{name}'
        new = f'{name}{psym}3'
        for i, label in enumerate(labels):
            labels[i] = label.replace(old, new)
        old = f'{name}*{name}'
        new = f'{name}{psym}2'
        for i, label in enumerate(labels):
            labels[i] = label.replace(old, new)

    return labels


def sparsify_dynamics_lstsq(theta, dxdt, lamb, n):
    """SINDy algorithm to find sparse polynomial model
    of dynamics using ordinary least-squares.
    """

    # Initial guess: Least-squares
    xi = np.linalg.lstsq(theta, dxdt, rcond=None)[0]

    for k in range(10):
        # Find small coefficients below threshold
        smallinds = np.abs(xi) < lamb
        xi[smallinds] = 0
        for ind in range(n):  # n is state dimension
            biginds = np.logical_not(smallinds[:, ind])
            # Regress dynamics onto remaining terms to find sparse xi
            xi[biginds, ind] = np.linalg.lstsq(theta[:, biginds], dxdt[:, ind],
                                               rcond=None)[0]

    return xi
